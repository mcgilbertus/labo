3 	 fread(nom_arch) 
1 	 set.seed(PARAM$semilla_primos) 
1 	 fread(nom_arch) 
12 	 set.seed(seed = seed, ...) 
12 	 set.seed(seed = seed, ...) 
12 	 set.seed(seed = seed, ...) 
1 	 fread(nom_arch) 
12 	 set.seed(seed = seed, ...) 
12 	 set.seed(seed = seed, ...) 
12 	 set.seed(seed = seed, ...) 
1 	 fread(nom_arch) 
1 	 lgb.Dataset(data = data.matrix(dataset[, campos_buenos, with = FALSE]),      label = dataset[, clase01], weight = dataset[, ifelse(get(PARAM$const$campo_clase) %in%          PARAM$clase_test_POS, 1.0000001, 1)], free_raw_data = FALSE) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 999983L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
2 	 lgb.importance(modelo_final) 
1 	 fwrite(tb_importancia, file = paste0(PARAM$files$output$FMimportancia,      sprintf("%03d", iteracion_bayesiana), ".txt"), sep = "\t") 
1 	 fwrite(tb_modelos, file = PARAM$files$output$tb_modelos, sep = "\t") 
1 	 fwrite(tb_prediccion, file = nom_pred, sep = "\t") 
1 	 fwrite(tb_predicciones, file = PARAM$files$output$tb_predicciones,      sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
8 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 353767L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 797917L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 301531L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 228751L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 453949L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 615767L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 910093L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 835979L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 632629L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 603817L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 189877L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 724573L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 743987L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 433033L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 472741L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 694591L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 577123L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 739301L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 339121L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 set.seed(parametros$seed) 
3 	 (new("functionWithTrace", .Data = function (params = list(),      data, nrounds = 100L, valids = list(), obj = NULL, eval = NULL,      verbose = 1L, record = TRUE, eval_freq = 1L, init_model = NULL,      colnames = NULL, categorical_feature = NULL, early_stopping_rounds = NULL,      callbacks = list(), reset_data = FALSE, serializable = TRUE)  {     .doTrace(exp_trace_log())     {         if (nrounds <= 0L) {             stop("nrounds should be greater than zero")         }         if (!lgb.is.Dataset(x = data)) {             stop("lgb.train: data must be an lgb.Dataset instance")         }         if (length(valids) > 0L) {             if (!identical(class(valids), "list") || !all(vapply(valids,                  lgb.is.Dataset, logical(1L)))) {                 stop("lgb.train: valids must be a list of lgb.Dataset elements")             }             evnames <- names(valids)             if (is.null(evnames) || !all(nzchar(evnames))) {                 stop("lgb.train: each element of valids must have a name")             }         }         params <- lgb.check.wrapper_param(main_param_name = "verbosity",              params = params, alternative_kwarg_value = verbose)         params <- lgb.check.wrapper_param(main_param_name = "num_iterations",              params = params, alternative_kwarg_value = nrounds)         params <- lgb.check.wrapper_param(main_param_name = "metric",              params = params, alternative_kwarg_value = NULL)         params <- lgb.check.wrapper_param(main_param_name = "objective",              params = params, alternative_kwarg_value = obj)         params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",              params = params, alternative_kwarg_value = early_stopping_rounds)         early_stopping_rounds <- params[["early_stopping_round"]]         fobj <- NULL         if (is.function(params$objective)) {             fobj <- params$objective             params$objective <- "none"         }         params <- lgb.check.eval(params = params, eval = eval)         eval_functions <- list(NULL)         if (is.function(eval)) {             eval_functions <- list(eval)         }         if (methods::is(eval, "list")) {             eval_functions <- Filter(f = is.function, x = eval)         }         predictor <- NULL         if (is.character(init_model)) {             predictor <- Predictor$new(modelfile = init_model)         }         else if (lgb.is.Booster(x = init_model)) {             predictor <- init_model$to_predictor()         }         begin_iteration <- 1L         if (!is.null(predictor)) {             begin_iteration <- predictor$current_iter() + 1L         }         end_iteration <- begin_iteration + params[["num_iterations"]] -              1L         interaction_constraints <- params[["interaction_constraints"]]         params["interaction_constraints"] <- NULL         data$update_params(params = params)         data$construct()         cnames <- NULL         if (!is.null(colnames)) {             cnames <- colnames         }         else if (!is.null(data$get_colnames())) {             cnames <- data$get_colnames()         }         params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,              column_names = cnames)         data$update_params(params)         data$.__enclos_env__$private$set_predictor(predictor)         if (!is.null(colnames)) {             data$set_colnames(colnames)         }         if (!is.null(categorical_feature)) {             data$set_categorical_feature(categorical_feature)         }         valid_contain_train <- FALSE         train_data_name <- "train"         reduced_valid_sets <- list()         if (length(valids) > 0L) {             for (key in names(valids)) {                 valid_data <- valids[[key]]                 if (identical(data, valid_data)) {                   valid_contain_train <- TRUE                   train_data_name <- key                   next                 }                 valid_data$update_params(params)                 valid_data$set_reference(data)                 reduced_valid_sets[[key]] <- valid_data             }         }         if (params[["verbosity"]] > 0L && eval_freq > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))         }         if (record && length(valids) > 0L) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())         }         using_early_stopping <- !is.null(early_stopping_rounds) &&              early_stopping_rounds > 0L         boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]         using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {             identical(params[[param]], "dart")         }))         if (using_dart) {             warning("Early stopping is not available in 'dart' mode.")             using_early_stopping <- FALSE             callbacks <- Filter(f = function(cb_func) {                 !identical(attr(cb_func, "name"), "cb_early_stop")             }, x = callbacks)         }         if (using_early_stopping) {             callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,                  first_metric_only = isTRUE(params[["first_metric_only"]]),                  verbose = params[["verbosity"]] > 0L))         }         cb <- categorize.callbacks(cb_list = callbacks)         booster <- Booster$new(params = params, train_set = data)         if (valid_contain_train) {             booster$set_train_data_name(name = train_data_name)         }         for (key in names(reduced_valid_sets)) {             booster$add_valid(data = reduced_valid_sets[[key]],                  name = key)         }         env <- CB_ENV$new()         env$model <- booster         env$begin_iteration <- begin_iteration         env$end_iteration <- end_iteration         for (i in seq.int(from = begin_iteration, to = end_iteration)) {             env$iteration <- i             env$eval_list <- list()             for (f in cb$pre_iter) {                 f(env)             }             booster$update(fobj = fobj)             eval_list <- list()             if (length(valids) > 0L) {                 for (eval_function in eval_functions) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }                 if (length(eval_functions) == 0L) {                   if (valid_contain_train) {                     eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                   }                   eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))                 }             }             env$eval_list <- eval_list             for (f in cb$post_iter) {                 f(env)             }             if (env$met_early_stop)                  break         }         non_train_valid_names <- names(valids)[!(names(valids) ==              train_data_name)]         first_valid_name <- non_train_valid_names[1L]         if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {             if (!is.null(eval_functions[1L])) {                 first_metric <- names(booster$record_evals[[first_valid_name]])[1L]             }             else {                 first_metric <- booster$.__enclos_env__$private$eval_names[1L]             }             .find_best <- which.min             if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {                 .find_best <- which.max             }             booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))             booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]         }         if (reset_data) {             booster_old <- list(best_iter = booster$best_iter,                  best_score = booster$best_score, record_evals = booster$record_evals)             booster <- lgb.load(model_str = booster$save_model_to_string())             booster$best_iter <- booster_old$best_iter             booster$best_score <- booster_old$best_score             booster$record_evals <- booster_old$record_evals         }         if (serializable) {             booster$save_raw()         }         return(booster)     } }, original = function (params = list(), data, nrounds = 100L,      valids = list(), obj = NULL, eval = NULL, verbose = 1L, record = TRUE,      eval_freq = 1L, init_model = NULL, colnames = NULL, categorical_feature = NULL,      early_stopping_rounds = NULL, callbacks = list(), reset_data = FALSE,      serializable = TRUE)  {     if (nrounds <= 0L) {         stop("nrounds should be greater than zero")     }     if (!lgb.is.Dataset(x = data)) {         stop("lgb.train: data must be an lgb.Dataset instance")     }     if (length(valids) > 0L) {         if (!identical(class(valids), "list") || !all(vapply(valids,              lgb.is.Dataset, logical(1L)))) {             stop("lgb.train: valids must be a list of lgb.Dataset elements")         }         evnames <- names(valids)         if (is.null(evnames) || !all(nzchar(evnames))) {             stop("lgb.train: each element of valids must have a name")         }     }     params <- lgb.check.wrapper_param(main_param_name = "verbosity",          params = params, alternative_kwarg_value = verbose)     params <- lgb.check.wrapper_param(main_param_name = "num_iterations",          params = params, alternative_kwarg_value = nrounds)     params <- lgb.check.wrapper_param(main_param_name = "metric",          params = params, alternative_kwarg_value = NULL)     params <- lgb.check.wrapper_param(main_param_name = "objective",          params = params, alternative_kwarg_value = obj)     params <- lgb.check.wrapper_param(main_param_name = "early_stopping_round",          params = params, alternative_kwarg_value = early_stopping_rounds)     early_stopping_rounds <- params[["early_stopping_round"]]     fobj <- NULL     if (is.function(params$objective)) {         fobj <- params$objective         params$objective <- "none"     }     params <- lgb.check.eval(params = params, eval = eval)     eval_functions <- list(NULL)     if (is.function(eval)) {         eval_functions <- list(eval)     }     if (methods::is(eval, "list")) {         eval_functions <- Filter(f = is.function, x = eval)     }     predictor <- NULL     if (is.character(init_model)) {         predictor <- Predictor$new(modelfile = init_model)     }     else if (lgb.is.Booster(x = init_model)) {         predictor <- init_model$to_predictor()     }     begin_iteration <- 1L     if (!is.null(predictor)) {         begin_iteration <- predictor$current_iter() + 1L     }     end_iteration <- begin_iteration + params[["num_iterations"]] -          1L     interaction_constraints <- params[["interaction_constraints"]]     params["interaction_constraints"] <- NULL     data$update_params(params = params)     data$construct()     cnames <- NULL     if (!is.null(colnames)) {         cnames <- colnames     }     else if (!is.null(data$get_colnames())) {         cnames <- data$get_colnames()     }     params[["interaction_constraints"]] <- lgb.check_interaction_constraints(interaction_constraints = interaction_constraints,          column_names = cnames)     data$update_params(params)     data$.__enclos_env__$private$set_predictor(predictor)     if (!is.null(colnames)) {         data$set_colnames(colnames)     }     if (!is.null(categorical_feature)) {         data$set_categorical_feature(categorical_feature)     }     valid_contain_train <- FALSE     train_data_name <- "train"     reduced_valid_sets <- list()     if (length(valids) > 0L) {         for (key in names(valids)) {             valid_data <- valids[[key]]             if (identical(data, valid_data)) {                 valid_contain_train <- TRUE                 train_data_name <- key                 next             }             valid_data$update_params(params)             valid_data$set_reference(data)             reduced_valid_sets[[key]] <- valid_data         }     }     if (params[["verbosity"]] > 0L && eval_freq > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_print_evaluation(period = eval_freq))     }     if (record && length(valids) > 0L) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_record_evaluation())     }     using_early_stopping <- !is.null(early_stopping_rounds) &&          early_stopping_rounds > 0L     boosting_param_names <- .PARAMETER_ALIASES()[["boosting"]]     using_dart <- any(sapply(X = boosting_param_names, FUN = function(param) {         identical(params[[param]], "dart")     }))     if (using_dart) {         warning("Early stopping is not available in 'dart' mode.")         using_early_stopping <- FALSE         callbacks <- Filter(f = function(cb_func) {             !identical(attr(cb_func, "name"), "cb_early_stop")         }, x = callbacks)     }     if (using_early_stopping) {         callbacks <- add.cb(cb_list = callbacks, cb = cb_early_stop(stopping_rounds = early_stopping_rounds,              first_metric_only = isTRUE(params[["first_metric_only"]]),              verbose = params[["verbosity"]] > 0L))     }     cb <- categorize.callbacks(cb_list = callbacks)     booster <- Booster$new(params = params, train_set = data)     if (valid_contain_train) {         booster$set_train_data_name(name = train_data_name)     }     for (key in names(reduced_valid_sets)) {         booster$add_valid(data = reduced_valid_sets[[key]], name = key)     }     env <- CB_ENV$new()     env$model <- booster     env$begin_iteration <- begin_iteration     env$end_iteration <- end_iteration     for (i in seq.int(from = begin_iteration, to = end_iteration)) {         env$iteration <- i         env$eval_list <- list()         for (f in cb$pre_iter) {             f(env)         }         booster$update(fobj = fobj)         eval_list <- list()         if (length(valids) > 0L) {             for (eval_function in eval_functions) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }             if (length(eval_functions) == 0L) {                 if (valid_contain_train) {                   eval_list <- append(eval_list, booster$eval_train(feval = eval_function))                 }                 eval_list <- append(eval_list, booster$eval_valid(feval = eval_function))             }         }         env$eval_list <- eval_list         for (f in cb$post_iter) {             f(env)         }         if (env$met_early_stop)              break     }     non_train_valid_names <- names(valids)[!(names(valids) ==          train_data_name)]     first_valid_name <- non_train_valid_names[1L]     if (record && length(non_train_valid_names) > 0L && is.na(env$best_score)) {         if (!is.null(eval_functions[1L])) {             first_metric <- names(booster$record_evals[[first_valid_name]])[1L]         }         else {             first_metric <- booster$.__enclos_env__$private$eval_names[1L]         }         .find_best <- which.min         if (isTRUE(env$eval_list[[1L]]$higher_better[1L])) {             .find_best <- which.max         }         booster$best_iter <- unname(.find_best(unlist(booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]])))         booster$best_score <- booster$record_evals[[first_valid_name]][[first_metric]][[.EVAL_KEY()]][[booster$best_iter]]     }     if (reset_data) {         booster_old <- list(best_iter = booster$best_iter, best_score = booster$best_score,              record_evals = booster$record_evals)         booster <- lgb.load(model_str = booster$save_model_to_string())         booster$best_iter <- booster_old$best_iter         booster$best_score <- booster_old$best_score         booster$record_evals <- booster_old$record_evals     }     if (serializable) {         booster$save_raw()     }     return(booster) }, source = <environment>))(params = list(lambda_l1 = 0L, lambda_l2 = 0L,      min_gain_to_split = 0L, bagging_fraction = 1L, pos_bagging_fraction = 1L,      neg_bagging_fraction = 1L, max_depth = -1L, max_bin = 31L,      seed = 629311L, extra_trees = FALSE, drop_rate = 0.1, max_drop = 50L,      skip_drop = 0.5, metric = "custom", first_metric_only = TRUE,      objective = "binary", boost_from_average = TRUE, force_row_wise = TRUE,      feature_pre_filter = FALSE, boosting = "gbdt", num_threads = 0L,      verbosity = -100L, learning_rate = 0.0765623064669408, feature_fraction = 0.154521770766121,      num_leaves = integer(0), min_data_in_leaf = 7024L, num_iterations = 154L),      data = <environment>, nrounds = 100L, obj = "regression",      verbose = -100L, eval_freq = 1L, early_stopping_rounds = NULL,      init_model = NULL, callbacks = list(), serializable = TRUE,      valids = list()) 
4 	 stats::runif(n) 
1 	 fwrite(tb_prediccion_semillerio, file = nom_pred_semillerio,      sep = "\t") 
1 	 fwrite(tb_predicciones, file = PARAM$files$output$tb_predicciones,      sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
1 	 fwrite(tb_prediccion_semillerio[, c(PARAM$const$campo_id, PARAM$const$campo_pred),      with = FALSE], file = nom_submit, sep = ",") 
1 	 fwrite(tb_submits, file = PARAM$files$output$tb_submits, sep = "\t") 
2 	 fwrite(tb_catalogo, file = EXP$environment$catalog, sep = "\t") 
2 	 fwrite(tb_catalogo, file = EXP$environment$catalog, sep = "\t") 
2 	 fwrite(tb_catalogo, file = EXP$environment$catalog, sep = "\t") 
